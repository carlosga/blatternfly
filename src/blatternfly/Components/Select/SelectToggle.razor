@namespace Blatternfly.Components
@inherits BaseComponent

<button
  type="@ButtonToggleType"
  class="pf-c-select__toggle"
  aria-expanded="@AriaExpanded"
  aria-haspopup="listbox"  
  @onclick="@ToggleHandler"
  @onclick:stopPropagation="true"
  @onkeydown="@KeyDownHandler"
  @onkeydown:stopPropagation="true"
  disabled="@IsDisabled"
  @attributes="AdditionalAttributes"
>
  @ChildContent
  <span class="pf-c-select__toggle-arrow">
    <CaretDownIcon />
  </span>
</button>

@code {
  /// HTML ID of dropdown toggle.
  [Parameter] public string Id { get; set; }

  /// Flag to indicate if select is open.
  [Parameter] public bool IsOpen { get; set; }

  /// Callback called when toggle is clicked.
  [Parameter] public EventCallback<bool> OnToggle { get; set; }

  /// Callback for toggle open on keyboard entry.
  [Parameter] public EventCallback OnEnter { get; set; }

  /// Callback for toggle close.
  [Parameter] public EventCallback OnClose { get; set; }

  /// Forces active state.
  [Parameter] public bool IsActive { get; set; }

  /// Display the toggle with no border or background.
  [Parameter] public bool IsPlain { get; set; }

  /// Flag indicating if select is disabled.
  [Parameter] public bool IsDisabled { get; set; }

  /// Type of the toggle button, defaults to 'button'.
  [Parameter] public ButtonType? Type { get; set; } = ButtonType.Button;

  /// Id of label for the Select aria-labelledby.
  [Parameter] public string AriaLabelledBy { get; set; }

  /// Label for toggle of select variants.
  [Parameter] public string AriaLabel { get; set; }

  /// Flag for variant, determines toggle rules and interaction.
  [Parameter] public SelectVariant Variant { get; set; }

  /// Flag indicating if select toggle has an clear button.
  [Parameter] public bool HasClearButton { get; set; }

  /// Flag indicating if select menu has a footer.
  [Parameter] public bool HasFooter { get; set; }

  private string AriaExpanded  { get => IsOpen ? "true" : "false"; }
  private string DisabledClass { get => IsDisabled ? "pf-m-disabled" : null; }
  private string PlainClass    { get => IsPlain ? "pf-m-plain" : null; }
  private string ActiveClass   { get => IsActive ? "pf-m-active" : null; }

  private string ButtonToggleType
  {
    get
    {
      return Type switch
      {
        ButtonType.Button => "button",
        ButtonType.Submit => "submit",
        ButtonType.Reset  => "reset",
        _                 => "button"
      };
    }
  }

  private async Task ToggleHandler(MouseEventArgs args)
  {
    IsOpen = !IsOpen;
    await OnToggle.InvokeAsync(IsOpen);
    if (IsOpen)
    {
      await OnClose.InvokeAsync();
    }
  }

  private Task KeyDownHandler(KeyboardEventArgs args)
  {
    return Task.CompletedTask;
  @*
    if ((args.Key === KeyTypes.Tab && !isOpen) ||
      (event.key !== KeyTypes.Enter && event.key !== KeyTypes.Space)
    ) {
      return;
    }
    event.preventDefault();
    if ((event.key === KeyTypes.Tab || event.key === KeyTypes.Enter || event.key === KeyTypes.Space) && isOpen) {
      onToggle(!isOpen);
      onClose();
      this.toggle.current.focus();
    } else if ((event.key === KeyTypes.Enter || event.key === KeyTypes.Space) && !isOpen) {
      onToggle(!isOpen);
      onEnter();
    }
    *@
  }
}
