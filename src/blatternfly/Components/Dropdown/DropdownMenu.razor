@namespace Blatternfly.Components
@using Microsoft.JSInterop
@inherits BaseComponent

<CascadingValue Value="this">
  <ul id="@MenuId"
      class="@CssClass @AlignmentClass"
      hidden="@IsHidden"
      role="menu"
      @attributes="AdditionalAttributes"
  >
    @ChildContent
  </ul>
</CascadingValue>

@code {
  [CascadingParameter] public Dropdown Parent { get; set; }
  
  private ElementReference Element { get; set; }

  /// Flag to indicate if menu is opened.
  [Parameter] public bool IsOpen { get; set; }

  /// Flag to indicate if menu should be opened on enter.
  [Parameter] public bool OpenedOnEnter { get; set; }

  /// Flag to indicate if the first dropdown item should gain initial focus, set false when adding
  /// a specific auto-focus item (like a current selection) otherwise leave as true.
  [Parameter] public bool AutoFocus { get; set; } = true;

  /// Indicates where menu will be aligned horizontally.
  [Parameter] public DropdownPosition Position { get; set; } = DropdownPosition.Left;

  /// Flag to indicate if menu is grouped.
  [Parameter] public bool IsGrouped { get; set; }

  private string _id = Utils.GetUniqueId("pf-dropdown-menu-id-");
   
  internal string MenuId { get => string.IsNullOrEmpty(InternalId) ? _id : InternalId; }
  
  private bool   IsHidden       { get => !IsOpen; }
  private string AlignmentClass { get => Position == DropdownPosition.Right ? "pf-m-align-right" : null; }
  private string CssClass
  {
    get => !string.IsNullOrEmpty(Parent?.MenuClass) ? Parent.MenuClass : "pf-c-dropdown__menu";
  }
  
  private List<DropdownItem> _items = new();
  
  internal void RegisterItem(DropdownItem item)
  {
    _items.Add(item);
  }
  
  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    await base.OnAfterRenderAsync(firstRender);
    
    if (firstRender)
    {
      if (IsOpen && OpenedOnEnter)
      {
        // TODO: Workaround for https://github.com/dotnet/aspnetcore/issues/30070
        await Task.Yield();
        
        if (AutoFocus)
        {
          await FocusFirstRefAsync();
        }
        else
        {
          await FocusFirstAutoFocusItemAsync();
        }
      }
    }
  }
  
  private async Task FocusFirstRefAsync()
  {
    if (_items is not null && _items.Count > 0)
    {
      var item = _items[0];
      await item.FocusAsync();
    }
  }

  private async Task FocusFirstAutoFocusItemAsync()
  {
    if (_items is not null && _items.Count > 0)
    {
      var item = _items.FirstOrDefault(x => x.AutoFocus);
      if (item is not null)
      {
        await item.FocusAsync(); 
      }
    }
  }
  
  internal async Task ChildKeyHandler(DropdownItem item, KeyhandlerDirection direction)
  {
    if (_items is null || _items.Count == 0) 
    {
      return;
    }
    var index     = _items.IndexOf(item);
    var nextIndex = _items.IndexOf(item);
    if (direction == KeyhandlerDirection.Up)
    {
      if (index == 0) 
      {
        // loop back to end
        nextIndex = _items.Count - 1;
      } 
      else
      {
        nextIndex = index - 1;
      }
    } 
    else if (direction == KeyhandlerDirection.Down) 
    {
      if (index == _items.Count - 1) 
      {
        // loop back to beginning
        nextIndex = 0;
      } 
      else
      {
        nextIndex = index + 1;
      }
    }
    
    var nextItem = _items[nextIndex];
    if (nextItem.IsDisabled)
    {
      await ChildKeyHandler(nextItem, direction); 
    }
    else
    {
      await _items[nextIndex].FocusAsync(); 
    }
  }  
}