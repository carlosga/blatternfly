@namespace Blatternfly.Components
@inherits BaseComponent
@using System.Reactive.Linq
@using Microsoft.JSInterop
@implements IDisposable
@inject IJSRuntime JS
@inject Observers.IWindowObserver WindowObserver

@if (Parent.IsHorizontal)
{
  <button 
    class="pf-c-nav__scroll-button" 
    aria-label="@AriaLeftScroll" 
    disabled="@_scrollViewAtStart"
    @onclick="ScrollLeft" 
  >
    <AngleLeftIcon />
  </button>
}
<ul 
  @attributes="AdditionalAttributes" 
  class="pf-c-nav__list @InternalCssClass" 
  @onscroll="HandleScrollButtons" 
  @ref="ElementReference"
>
  @ChildContent
</ul>
@if (Parent.IsHorizontal)
{
  <button 
    class="pf-c-nav__scroll-button" 
    aria-label="@AriaRightScroll" 
    disabled="@_scrollViewAtEnd"
    @onclick="ScrollRight" 
  >
    <AngleRightIcon />
  </button>
}

@code {
  /// Parent Nav control
  [CascadingParameter] public Nav Parent { get; set; }

  /// aria-label for the left scroll button.
  [Parameter] public string AriaLeftScroll { get; set; } = "Scroll left";

  /// aria-label for the right scroll button.
  [Parameter] public string AriaRightScroll { get; set; } = "Scroll right";
  
  private ElementReference ElementReference { get; set; }
  
  private bool          _scrollViewAtStart = false;
  private bool          _scrollViewAtEnd   = false;
  private List<NavItem> _items             = new(10);
  private IDisposable   _resizeSubscription;
  
  public void Dispose()
  {
    _resizeSubscription?.Dispose();
  }  
  
  internal void RegisterItem(NavItem item)
  {
    if (!Parent.IsHorizontal)
    {
      return;
    }
    
    if (!_items.Contains(item))
    {
      _items.Add(item);
    }
  }

  protected override async Task OnInitializedAsync()
  {
    await base.OnInitializedAsync();
    
    if (Parent.IsHorizontal)
    {
      _resizeSubscription = WindowObserver
        .OnResize
        .Throttle(TimeSpan.FromMilliseconds(250))
        .Subscribe(async r => await HandleScrollButtons());
    }
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    await base.OnAfterRenderAsync(firstRender);
    
    if (firstRender)
    {
      await HandleScrollButtons();
    }
  }

  private async Task HandleScrollButtons()
  {
    if (_items.Count > 0)
    {
      var firstChild = _items[0].ElementReference;
      var lastChild  = _items[^1].ElementReference;
      
      // check if it elements are in view
      _scrollViewAtStart = await IsElementInView(ElementReference, firstChild, false);
      _scrollViewAtEnd   = await IsElementInView(ElementReference, lastChild, false);
      Parent.UpdateIsScrollableState(!_scrollViewAtStart || !_scrollViewAtEnd);
    }
  }

  private async Task ScrollLeft()
  {
    NavItem firstElementInView   = null;
    NavItem lastElementOutOfView = null;
    for (var i = 0; i < _items.Count && firstElementInView is null; i++) 
    {
      var isInView = await IsElementInView(ElementReference, _items[i].ElementReference, false);
      if (isInView) 
      {
        firstElementInView   = _items[i];
        lastElementOutOfView = _items[i - 1];
      }
    }
    if (lastElementOutOfView is not null) 
    {
      var scrollSize = await lastElementOutOfView.ElementReference.GetScrollSize(JS);
      await ElementReference.ScrollLeft(JS, -scrollSize.Width);
    }
    await HandleScrollButtons();  
  }

  private async Task ScrollRight()
  {
    NavItem firstElementOutOfView = null;
    NavItem lastElementInView     = null;
    for (var i = _items.Count - 1; i >= 0 && lastElementInView is null; i--) 
    {
      var isInView = await IsElementInView(ElementReference, _items[i].ElementReference, false);
      if (isInView) 
      {
        lastElementInView     =_items[i];
        firstElementOutOfView =_items[i + 1];
      }
    }
    if (firstElementOutOfView is not null)
    {
      var scrollSize = await firstElementOutOfView.ElementReference.GetScrollSize(JS);
      await ElementReference.ScrollLeft(JS, scrollSize.Width);
    }
    await HandleScrollButtons();    
  }
  
  private async Task<bool> IsElementInView(ElementReference container, ElementReference element, bool partial) 
  {
    var containerBounds      = await container.GetBoundingClientRect(JS);
    var elementBounds        = await element.GetBoundingClientRect(JS);
    var containerBoundsLeft  = Math.Floor(containerBounds.Left);
    var containerBoundsRight = Math.Floor(containerBounds.Right);
    var elementBoundsLeft    = Math.Floor(elementBounds.Left);
    var elementBoundsRight   = Math.Floor(elementBounds.Right);

    // Check if in view
    var isTotallyInView = elementBoundsLeft >= containerBoundsLeft && elementBoundsRight <= containerBoundsRight;
    var isPartiallyInView = 
        partial 
          && ((elementBoundsLeft < containerBoundsLeft && elementBoundsRight > containerBoundsLeft) 
              || (elementBoundsRight > containerBoundsRight && elementBoundsLeft < containerBoundsRight));

    // Return outcome
    return isTotallyInView || isPartiallyInView;
  }  
}