@namespace Blatternfly.Components
@inherits BaseComponent
@implements IDisposable
@inject IFloatingInteropModule FloatingInterop
@inject IWindowObserver WindowObserver

@if (IsVisible)
{
  <FocusTrap
    @attributes="AdditionalAttributes"
    id="@id"
    Active="@WithFocusTrap"
    FocusTrapOptions="@FocusTrapOptions"
    class="@CssClass"
    role="dialog"
    aria-modal="true"
    aria-label="@FocusTrapAriaLabel"
    aria-labelledby="@FocusTrapAriaLabelledBy"
    aria-describedby="@FocusTrapAriaDescribedBy"
    style="@CssStyle"
    @onmousedown="OnContentMouseDown"
  >
    <PopoverArrow />
    <PopoverContent>
      @if (ShowClose)
      {
        <PopoverCloseButton OnClose="@ClosePopover" aria-label="@CloseBtnAriaLabel" />
      }
      @if (HeaderContent is not null)
      {
        <PopoverHeader
          id="@HeaderId"
          Icon="@HeaderIcon"
          AlertSeverityVariant="@AlertSeverityVariant"
          AlertSeverityScreenReaderText="@AlertSeverityScreenReaderTextValue"
          TitleHeadingLevel="@HeaderComponent"
        >
          @HeaderContent
        </PopoverHeader>
      }
      <PopoverBody id="@BodyId">
        @BodyContent
      </PopoverBody>
      @if (FooterContent is not null)
      {
        <PopoverFooter id="@FooterId">
          @FooterContent
        </PopoverFooter>
      }
    </PopoverContent>
  </FocusTrap>
}
@ChildContent

@code {
  /// Accessible label, required when header is not present.
  [Parameter] public string AriaLabel { get; set; }

  /// Body content
  [Parameter] public RenderFragment BodyContent { get; set; }

  /// The reference element to which the Popover is relatively placed to.
  /// If you can wrap the reference with the Popover, you can use the children prop instead.
  [Parameter] public string Reference { get; set; }

  /// Aria label for the Close button.
  [Parameter] public string CloseBtnAriaLabel { get; set; } = "Close";

  /// Whether to show the close button.
  [Parameter] public bool ShowClose { get; set; } = true;

  /// Distance of the popover to its target, defaults to 25.
  [Parameter] public int Distance { get; set; } = 25;

  /// If true, tries to keep the popover in view by flipping it if necessary
  /// If the position is set to 'auto', this prop is ignored
  [Parameter] public bool EnableFlip { get; set; } = true;

  /// The desired position to flip the tooltip to if the initial position is not possible.
  /// By setting this prop to 'flip' it attempts to flip the tooltip to the opposite side if there is no space.
  /// You can also pass an array of positions that determines the flip order. It should contain the initial position
  /// followed by alternative positions if that position is unavailable.
  /// Example: Initial position is 'top'. Button with tooltip is in the top right corner. 'flipBehavior' is set to
  /// ['top', 'right', 'left']. Since there is no space to the top, it checks if right is available. There's also no
  /// space to the right, so it finally shows the tooltip on the left.
  [Parameter] public PopoverPosition[] FlipBehavior { get; set; } =
  {
    PopoverPosition.Top,
    PopoverPosition.Right,
    PopoverPosition.Bottom,
    PopoverPosition.Left,
    PopoverPosition.Top,
    PopoverPosition.Right,
    PopoverPosition.Bottom
  };

  /// Footer content
  [Parameter] public RenderFragment FooterContent { get; set; }

  /// Simple header content to be placed within a title.
  [Parameter] public RenderFragment HeaderContent { get; set; }

  /// Sets the heading level to use for the popover header. Default is h6..
  [Parameter] public HeadingLevel? HeaderComponent { get; set; } = HeadingLevel.h6;

  /// @beta Icon to be displayed in the popover header **/
  [Parameter] public RenderFragment HeaderIcon { get; set; }

  /// @beta Severity variants for an alert popover. This modifies the color of the header to match the severity..
  [Parameter] public AlertVariant? AlertSeverityVariant { get; set; }

  /// @beta Text announced by screen reader when alert severity variant is set to indicate severity level.
  [Parameter] public string AlertSeverityScreenReaderText { get; set; }

  /// Hides the popover when a click occurs outside (only works if isVisible is not controlled by the user).
  [Parameter] public bool HideOnOutsideClick { get; set; }

  /// True to show the popover programmatically. Used in conjunction with the shouldClose prop.
  /// By default, the popover child element handles click events automatically. If you want to control this programmatically,
  /// the popover will not auto-close if the Close button is clicked, ESC key is used, or if a click occurs outside the popover.
  /// Instead, the consumer is responsible for closing the popover themselves by adding a callback listener for the shouldClose prop.
  [Parameter] public bool IsVisible { get; set; }

  /// Minimum width of the popover (default 6.25rem).
  [Parameter] public string MinWidth { get; set; }

  /// Maximum width of the popover (default 18.75rem).
  [Parameter] public string MaxWidth { get; set; }

  /// Lifecycle function invoked when the popover has fully transitioned out.
  [Parameter] public EventCallback OnHidden { get; set; }

  /// Lifecycle function invoked when the popover begins to transition out.
  [Parameter] public EventCallback OnHide { get; set; }

  /// Lifecycle function invoked when the popover has been mounted to the DOM.
  [Parameter] public EventCallback OnMount { get; set; }

  /// Lifecycle function invoked when the popover begins to transition in.
  [Parameter] public EventCallback OnShow { get; set; }

  /// Lifecycle function invoked when the popover has fully transitioned in.
  [Parameter] public EventCallback OnShown { get; set; }

  /// Popover position. Note: With 'enableFlip' set to true,
  /// it will change the position if there is not enough space for the starting position.
  /// The behavior of where it flips to can be controlled through the flipBehavior prop.
  [Parameter] public PopoverPosition? Position { get; set; }

  /// Callback function that is only invoked when isVisible is also controlled. Called when the popover Close button is
  /// clicked, Enter key was used on it, or the ESC key is used.
  [Parameter] public EventCallback ShouldClose { get; set; }

  /// Callback function that is only invoked when isVisible is also controlled. Called when the Enter key is
  /// used on the focused trigger
  [Parameter] public EventCallback ShouldOpen { get; set; }

  /// z-index of the popover.
  [Parameter] public int ZIndex { get; set; } = 9999;

  /// CSS fade transition animation duration.
  [Parameter] public int AnimationDuration { get; set; } = 300;

  /// id used as part of the various popover elements (popover-${id}-header/body/footer).
  [Parameter] public string id { get; set; }

  /// Whether to trap focus in the popover.
  [Parameter] public bool WithFocusTrap { get; set; }

  /// Removes fixed-width and allows width to be defined by contents.
  [Parameter] public bool HasAutoWidth { get; set; }

  /// Allows content to touch edges of popover container.
  [Parameter] public bool HasNoPadding { get; set; }

  private string CssStyle => new StyleBuilder()
    .AddStyle("--pf-c-popover--MinWidth" , MinWidth, HasCustomMinWidth)
    .AddStyle("--pf-c-popover--MaxWidth" , MinWidth, HasCustomMinWidth)
    .AddStyle("z-index"                  , ZIndex)
    .AddStyle("opacity"                  , 1)
    .AddStyle("transition"               , $"opacity ${AnimationDuration}ms cubic-bezier(.54, 1.5, .38, 1.11)")
    .AddStyle("position"                 , "absolute")
    .AddStyle("top"                      , "0")
    .AddStyle("left"                     , "0")
    .AddStyle("transform"                , () => $"translate3d({Placement.X}px,{Placement.Y}px,0)", Placement is not null)
    .Build();

  private string CssClass => new CssBuilder("pf-c-popover")
    .AddClass("pf-m-success"      , AlertSeverityVariant is AlertVariant.Success)
    .AddClass("pf-m-danger"       , AlertSeverityVariant is AlertVariant.Danger)
    .AddClass("pf-m-warning"      , AlertSeverityVariant is AlertVariant.Warning)
    .AddClass("pf-m-info"         , AlertSeverityVariant is AlertVariant.Info)
    .AddClass("pf-m-default"      , AlertSeverityVariant is AlertVariant.Default)
    .AddClass("pf-m-no-padding"   , HasNoPadding)
    .AddClass("pf-m-width-auto"   , HasAutoWidth)
    .AddClass("pf-m-top"          , Placement is not null && Placement.Placement is PopoverPosition.Top)
    .AddClass("pf-m-bottom"       , Placement is not null && Placement.Placement is PopoverPosition.Bottom)
    .AddClass("pf-m-left"         , Placement is not null && Placement.Placement is PopoverPosition.Left)
    .AddClass("pf-m-right"        , Placement is not null && Placement.Placement is PopoverPosition.Right)
    .AddClass("pf-m-top-left"     , Placement is not null && Placement.Placement is PopoverPosition.TopStart)
    .AddClass("pf-m-top-right"    , Placement is not null && Placement.Placement is PopoverPosition.TopEnd)
    .AddClass("pf-m-bottom-left"  , Placement is not null && Placement.Placement is PopoverPosition.BottomStart)
    .AddClass("pf-m-bottom-right" , Placement is not null && Placement.Placement is PopoverPosition.BottomEnd)
    .AddClass("pf-m-left-top"     , Placement is not null && Placement.Placement is PopoverPosition.LeftStart)
    .AddClass("pf-m-left-bottom"  , Placement is not null && Placement.Placement is PopoverPosition.LeftEnd)
    .AddClass("pf-m-right-top"    , Placement is not null && Placement.Placement is PopoverPosition.RightStart)
    .AddClass("pf-m-right-bottom" , Placement is not null && Placement.Placement is PopoverPosition.RightEnd)
    .Build();

  private string FocusTrapAriaLabel       { get => HeaderContent is not null ? null : AriaLabel; }
  private string FocusTrapAriaLabelledBy  { get => HeaderContent is not null ? $"popover-{id}-header" : null; }
  private string FocusTrapAriaDescribedBy { get => $"popover-{id}-body"; }

  private bool HasCustomMinWidth { get => !string.IsNullOrEmpty(MinWidth); }
  private bool HasCustomMaxWidth { get => !string.IsNullOrEmpty(MaxWidth); }

  private string AlertSeverityScreenReaderTextValue
  {
    get => AlertSeverityScreenReaderText ?? $"{AlertSeverityVariant} alert:";
  }

  private string HeaderId { get => $"popover-{id}-header"; }
  private string BodyId   { get => $"popover-{id}-body"; }
  private string FooterId { get => $"popover-{id}-footer"; }

  private FocusTrapOptions FocusTrapOptions => new FocusTrapOptions
  {
    ReturnFocusOnDeactivate = true,
    ClickOutsideDeactivates = true,
    PreventScroll           = true
  };

  private FloatingPlacement<PopoverPosition> Placement { get; set; }
  private FloatingOptions<PopoverPosition> Options => new FloatingOptions<PopoverPosition>
  {
    Distance           = Distance,
    Placement          = Position ?? PopoverPosition.Top,
    EnableFlip         = Position is PopoverPosition.Auto || EnableFlip,
    FallbackPlacements = (Position is PopoverPosition.Auto || EnableFlip) ? FlipBehavior : null
  };

  private IDisposable _windowClickSubscription;
  public void Dispose()
  {
    _windowClickSubscription?.Dispose();
  }

  protected override void OnInitialized()
  {
    base.OnInitialized();

    _windowClickSubscription = WindowObserver.OnClick.Subscribe(async e => await OnWindowClick(e));
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (string.IsNullOrEmpty(id))
    {
      throw new InvalidOperationException("Popover: Popover requires an id to be specified");
    }
    if (string.IsNullOrEmpty(Reference))
    {
      throw new InvalidOperationException("Popover: Popover requires a reference element id to be specified");
    }

    await base.OnAfterRenderAsync(firstRender);

    if (IsVisible && Placement is null)
    {
      Placement = await FloatingInterop.ComputePositionAsync<PopoverPosition>(Reference, id, Options);
      StateHasChanged();
    }
    else if (!IsVisible && Placement is not null)
    {
      Placement = null;
      StateHasChanged();
    }
  }

  private void OnContentMouseDown(MouseEventArgs _)
  {
    if (WithFocusTrap) {
      WithFocusTrap = false;
    }
  }

  private async Task ClosePopover(MouseEventArgs _)
  {
    await Hide();
  }

  private async Task OnWindowClick(MouseEvent e)
  {
    var clickedOnPopover   = e.ComposedPath?.Any(x => x == id);
    var clickedOnReference = e.ComposedPath?.Any(x => x == Reference);
    if (IsVisible && !clickedOnPopover.GetValueOrDefault() && !clickedOnReference.GetValueOrDefault())
    {
      await Hide();
    }
  }

  private async Task Hide()
  {
    await OnHide.InvokeAsync();
    IsVisible = false;
    await OnHidden.InvokeAsync();
  }
}